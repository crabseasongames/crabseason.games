<html>
<head>
<style>

body {
  margin: 0;
  display: flex;
  justify-content: space-evenly;
  align-items: center;
  flex-direction: row;
}

 canvas {
  border: 4px solid black;
} 

.hidden {
  display: none;
}

#tuggTurn {
  visibility: hidden;
}

@font-face {
  font-family: dinotopia;
  src: url(dinopia-font/DinopiaRegular-mLrO9.otf);
}


#oofTurn {
  font-family: dinotopia;
  visibility: hidden;
}


</style>

</head>
<body>
<div id="oofTurn">Oof Turn</div>
<div id="tuggTurn" class="hidden">Tugg Turn</div>
<canvas id="board" width="640" height="800"></canvas>
<canvas id="info" width="350" height="800"></canvas>
<script>

const boardCanvas = document.getElementById('board');
const ctx = boardCanvas.getContext('2d');
const infoCanvas = document.getElementById('info');
const infoCtx = infoCanvas.getContext('2d');
const lightSquare = '#956205';
const darkSquare = '#c1861a';
const highlightedColor = '#ef4141';
const tuggColor = '#000';
const oofColor = '#fff';
/// empty = 0, ORock = 1, Oguy = 2, TRock = 3, TGuy = 4
const startingBoard = [
  [3, 3, 3, 4, 3, 3, 3, 3],
  [3, 3, 3, 3, 3, 3, 3, 3],
  [0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0],
  [1, 1, 1, 1, 1, 1, 1, 1],
  [1, 1, 1, 2, 1, 1, 1, 1]
];

const empty = () => { return [ [], [], [], [], [], [], [], [] ]; };

let highlightedSquares = empty();
let highlightedEndzone = empty();
let allowedMoves = empty();
let activePiece = false;

let board = startingBoard;
let moveMode = false;
let oofTurn = true;
let throwRockAllowed = false;
const squareSize = 80;
let lives = 3;

document.fonts.ready.then( ()=>{
  function drawBoard() {
    ctx.clearRect(0, 0, 800, squareSize);
    ctx.clearRect(0, 800, 800, squareSize);
    for (let i = 0; i < 8; i++) {
      for (let j = 0; j < 8; j++) {
        let color = (i + j) % 2 == 0 ? lightSquare : darkSquare;
        ctx.fillStyle = color ;
        ctx.fillRect(i * squareSize, (j + 1) * squareSize, squareSize, squareSize);

        if (highlightedSquares[i][j] || allowedMoves[i][j]) {
          ctx.fillStyle = highlightedColor;
          ctx.fillRect(i * squareSize, (j + 1) * squareSize, squareSize, squareSize);
          ctx.fillStyle = color;
          ctx.fillRect(i * squareSize + (squareSize * .1), (j + 1) * squareSize + (squareSize * .1), squareSize * .8, squareSize * .8);
        }

        let piece = getPiece([i, j]);
        if (piece){
          drawPiece([i, j], piece);
        }
      }
    }
    for (let i = 0; i < 8; i++) {
      if(oofTurn && highlightedEndzone[i][0]) {
        ctx.beginPath();
        ctx.arc(squareSize*i + squareSize * .5, squareSize * .5, squareSize * .33, 0, 2*Math.PI)
        ctx.fillStyle = highlightedColor;
        ctx.fill()
      } else if (!oofTurn && highlightedEndzone[i][1]) {
        ctx.beginPath();
        ctx.arc(squareSize*i + squareSize * .5, squareSize * 8.5, squareSize * .33, 0, 2*Math.PI)
        ctx.fillStyle = highlightedColor;
        ctx.fill()
      }
    }
  }

  function drawPiece(position, piece) {
    let p = [position[0], position[1] + 1];

    let pieceColor = (piece == 1 || piece == 2) ? oofColor : tuggColor
    if (piece == 1 || piece == 3){
      ctx.beginPath();
      ctx.arc(squareSize*p[0] + squareSize * .5, squareSize*p[1] + squareSize * .5, squareSize * .33, 0, 2*Math.PI)
      ctx.fillStyle = pieceColor;
      ctx.fill()
    } else {
      ctx.beginPath();
      ctx.arc(squareSize*p[0] + squareSize * .5, squareSize*p[1] + squareSize * .5, squareSize * .15, 0, 2*Math.PI)
      ctx.moveTo(squareSize * p[0] + squareSize * .1 , squareSize * p[1] + squareSize * .1);
      ctx.lineTo(squareSize * p[0] + squareSize * .5, squareSize * p[1] + squareSize * .5);
      ctx.lineTo(squareSize * p[0] + squareSize * .1, squareSize * p[1] + squareSize * .9);
      ctx.lineTo(squareSize * p[0] + squareSize * .9, squareSize * p[1] + squareSize * .9);
      ctx.lineTo(squareSize * p[0] + squareSize * .5, squareSize * p[1] + squareSize * .5);
      ctx.lineTo(squareSize * p[0] + squareSize * .9, squareSize * p[1] + squareSize * .1);
      ctx.lineTo(squareSize * p[0] + squareSize, squareSize * p[1] + squareSize * .1);
      ctx.fillStyle = pieceColor;
      ctx.fill()
      ctx.closePath();
    }
  }

  function drawInfo() {
    infoCtx.font = "30px dinotopia";
    infoCtx.fillText("Hello World",10,80);
  }

  function draw(){
    drawBoard()
    drawInfo()
  }

  function getPosition(x, y) {
    let boundx = (c) => { return Math.min((squareSize * 8) - 1, Math.max(0, c)); };
    let boundy = (c) => { return Math.min((squareSize * 9) - 1, Math.max(-squareSize, c)); };
    return([Math.floor(boundx(x) / squareSize), Math.floor(boundy(y - squareSize) / squareSize)]);
  }

  function isOpposing(pa, pb) {
    return (
      (isOofPiece(pa)) && (!isOofPiece(pb))
    ) || (
      (isOofPiece(pb)) && (!isOofPiece(pa))
    );
  }

  function getAllowedMoves(position) {
    if(getPiece(position) == 2 || getPiece(position) == 4) {
      return getAllowedGuyMoves(position)
    } else {
      return getAllowedRockMoves(position)
    }
  }

  function getAllowedRockMoves(position) {
    throwRockAllowed = false;
    let allowedMoves = empty();
    let i = position[0];
    while (++i < 8 && !getPiece([i, position[1]])) {
      allowedMoves[i][position[1]] = true;
    }
    if (i < 8) {
      allowedMoves[i][position[1]] = isOpposing(position, [i, position[1]]);
    }

    i = position[0];
    while (--i >= 0 && !getPiece([i, position[1]])) {
      allowedMoves[i][position[1]] = true;
    }
    if (i >= 0) {
      allowedMoves[i][position[1]] = isOpposing(position, [i, position[1]]);
    }

    i = position[1];
    while (++i < 8 && !getPiece([position[0], i])) {
      allowedMoves[position[0]][i] = true;
    }
    if (i < 8) {
      allowedMoves[position[0]][i] = isOpposing(position, [position[0], i]);
    } else if (!isOofPiece(position)) {
      throwRockAllowed = true;
      highlightedEndzone[position[0]][oofTurn ? 0 : 1] = true;
    }

    i = position[1];
    while (--i >= 0 && !getPiece([position[0], i])) {
      allowedMoves[position[0]][i] = true;
    }
    if (i >= 0) {
      allowedMoves[position[0]][i] = isOpposing(position, [position[0], i]);
    } else if (isOofPiece(position)) {
      throwRockAllowed = true;
      highlightedEndzone[position[0]][oofTurn ? 0 : 1] = true;
    }
    return allowedMoves;
  }

  function getAllowedGuyMoves(position) {
    let allowedMoves = empty();
    let i = position[0] + 1;

    if (i < 8) {
      allowedMoves[i][position[1]] = !getPiece([i, position[1]]) || isOpposing(position, [i, position[1]]);
    }

    i = position[0] - 1;

    if (i >= 0) {
      allowedMoves[i][position[1]] = !getPiece([i, position[1]]) || isOpposing(position, [i, position[1]]);
    }

    i = position[1] + 1;

    if (i < 8) {
      allowedMoves[position[0]][i] = !getPiece([position[0], 1]) || isOpposing(position, [position[0], i]);
    }

    i = position[1] - 1;

    if (i >= 0) {
      allowedMoves[position[0]][i] = !getPiece([position[0], 1]) || isOpposing(position, [position[0], i]);
    }

    return allowedMoves;
  }

  function isOofPiece (position) {
    if (getPiece(position) == 1 || getPiece(position) == 2) {
      return true;
    } else {
      return false;
    }
  }

  function getPiece(position) {
    if (position[1] == -1 || position[1] == 8) {
      return -1
    } else {
      return board[position[1]][position[0]];
    }
  }

  function changeTurn() {
    oofTurn = !oofTurn
    if (!oofTurn) {
      document.getElementById("tuggTurn").classList.remove("hidden")
      document.getElementById("oofTurn").classList.add("hidden")
    } else {
      document.getElementById("tuggTurn").classList.add("hidden")
      document.getElementById("oofTurn").classList.remove("hidden")
    }
  }

  function throwRock () {
    console.log('outch');
    board[activePiece[1]][activePiece[0]] = 0;
  }

  boardCanvas.addEventListener("mousemove", (e)=>{
    let position = getPosition(e.offsetX, e.offsetY);
    if (!moveMode) {
      highlightedSquares = empty();
      highlightedSquares[position[0]][position[1]] = true;
      drawBoard();
    }
  });

  boardCanvas.addEventListener("click", (e) => {
    let position = getPosition(e.offsetX, e.offsetY);
    let piece = getPiece(position);
    if (!moveMode && piece && (isOofPiece(position) && oofTurn || !isOofPiece(position) && !oofTurn)) {
      moveMode = true;
      highlightedSquares = empty();
      highlightedEndzone = empty();
      allowedMoves = getAllowedMoves(position);
      activePiece = position;
    } else if (moveMode) {
      if (piece >= 0 && allowedMoves[position[0]][position[1]]) {
        board[position[1]][position[0]] = board[activePiece[1]][activePiece[0]];
        board[activePiece[1]][activePiece[0]] = 0;
        changeTurn()
      } else if(throwRockAllowed && (position[1] == -1 && oofTurn || position[1] == 8 && !oofTurn)){
        throwRock()
        changeTurn()
      }
      highlightedSquares = empty();
      highlightedEndzone = empty();
      allowedMoves = empty();
      moveMode = false;
    }
    draw();
  });

  draw();
})
</script>
</body>
</html>