<html>
<head>
<style>

body {
  margin: 0;
  display: flex;
  justify-content: space-evenly;
  align-items: center;
  flex-direction: row;
}

 canvas {
  border: 4px solid black;
} 

.hidden {
  display: none;
}

#tuggTurn {
  visibility: hidden;
}

@font-face {
  font-family: dinotopia;
  src: url(dinopia-font/DinopiaRegular-mLrO9.otf);
}


#font {
  position: absolute;
  font-family: dinotopia;
  visibility: hidden;
}


</style>

</head>
<body>
<canvas id="board" width="560" height="700"></canvas>
<canvas id="info" width="350" height="700"></canvas>
<div id="font">sup</div>
<script>

const boardCanvas = document.getElementById('board');
const ctx = boardCanvas.getContext('2d');
const infoCanvas = document.getElementById('info');
const infoCtx = infoCanvas.getContext('2d');
const lightSquare = '#956205';
const darkSquare = '#c1861a';
const highlightedColor = '#ef4141';
const tuggColor = '#000';
const oofColor = '#fff';
const squareSize = 70;
const lifeSize = 70;
const maxHp = 3;
/// empty = 0, ORock = 1, Oguy = 2, TRock = 3, TGuy = 4
const startingBoard = [
  [4, 4, 4, 4, 4, 4, 4, 4],
  [4, 4, 4, 4, 4, 4, 4, 4],
  [0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0],
  [2, 2, 2, 2, 2, 2, 2, 2],
  [2, 2, 2, 2, 2, 2, 2, 2]
];

const empty = () => { return [ [], [], [], [], [], [], [], [] ]; };

let highlightedSquares = empty();
let highlightedEndzone = empty();
let allowedMoves = empty();
let activePosition = false;

let board = startingBoard;
let moveMode = false;
let oofTurn = true;
let throwRockAllowed = false;
let oofHp = maxHp;
let tuggHp = maxHp;

let state = {
  board: startingBoard,
  oofHp: maxHp,
  tuggHp: maxHp,
  throwRockAllowed: false,
  allowedMoves: empty()
};

function send(type, data) {
  ws.send(JSON.stringify({
    type: type,
    data: data
  }));
}

const ws = new WebSocket(location.search.slice(1) == "LOCAL" ? "ws://localhost:3000" : "wss://crabseason-games-3cf54d5c76c6.herokuapp.com");

// ws.addEventListener("open", (event) => {
//   console.log("websocket connection opened");
//   console.log(event);
//   send("register", userId);

// });

// ws.addEventListener("message", (event) => {

// });

document.fonts.ready.then(()=>{
  function drawBoard() {
    ctx.clearRect(0, 0, 8 * squareSize, squareSize);
    ctx.clearRect(0, 9 * squareSize, 8 * squareSize, squareSize);
    for (let i = 0; i < 8; i++) {
      for (let j = 0; j < 8; j++) {
        let color = (i + j) % 2 == 0 ? lightSquare : darkSquare;
        ctx.fillStyle = color ;
        ctx.fillRect(i * squareSize, (j + 1) * squareSize, squareSize, squareSize);

        if (highlightedSquares[i][j] || allowedMoves[i][j]) {
          ctx.fillStyle = highlightedColor;
          ctx.fillRect(i * squareSize, (j + 1) * squareSize, squareSize, squareSize);
          ctx.fillStyle = color;
          ctx.fillRect(i * squareSize + (squareSize * .1), (j + 1) * squareSize + (squareSize * .1), squareSize * .8, squareSize * .8);
        }

        let piece = getPiece([i, j]);
        if (piece){
          drawPiece([i, j], piece);
        }
      }
    }
    for (let i = 0; i < 8; i++) {
      if(oofTurn && highlightedEndzone[i][0]) {
        ctx.beginPath();
        ctx.arc(squareSize*i + squareSize * .5, squareSize * .5, squareSize * .33, 0, 2*Math.PI)
        ctx.fillStyle = highlightedColor;
        ctx.fill()
      } else if (!oofTurn && highlightedEndzone[i][1]) {
        ctx.beginPath();
        ctx.arc(squareSize*i + squareSize * .5, squareSize * 9.5, squareSize * .33, 0, 2*Math.PI)
        ctx.fillStyle = highlightedColor;
        ctx.fill()
      }
    }
  }

  function drawPiece(position, piece) {
    let p = [position[0], position[1] + 1];

    let pieceColor = (piece == 1 || piece == 2) ? oofColor : tuggColor
    if (piece == 1 || piece == 3){
      ctx.beginPath();
      ctx.arc(squareSize*p[0] + squareSize * .5, squareSize*p[1] + squareSize * .5, squareSize * .33, 0, 2*Math.PI)
      ctx.fillStyle = pieceColor;
      ctx.fill()
    } else {
      ctx.beginPath();
      ctx.arc(squareSize*p[0] + squareSize * .5, squareSize*p[1] + squareSize * .5, squareSize * .15, 0, 2*Math.PI)
      ctx.moveTo(squareSize * p[0] + squareSize * .1 , squareSize * p[1] + squareSize * .1);
      ctx.lineTo(squareSize * p[0] + squareSize * .5, squareSize * p[1] + squareSize * .5);
      ctx.lineTo(squareSize * p[0] + squareSize * .1, squareSize * p[1] + squareSize * .9);
      ctx.lineTo(squareSize * p[0] + squareSize * .9, squareSize * p[1] + squareSize * .9);
      ctx.lineTo(squareSize * p[0] + squareSize * .5, squareSize * p[1] + squareSize * .5);
      ctx.lineTo(squareSize * p[0] + squareSize * .9, squareSize * p[1] + squareSize * .1);
      ctx.lineTo(squareSize * p[0] + squareSize, squareSize * p[1] + squareSize * .1);
      ctx.fillStyle = pieceColor;
      ctx.fill()
      ctx.closePath();
    }
  }

  function drawInfo() {
    infoCtx.clearRect(0, 0, 350, 10 * squareSize);
    const leftMargin = 20;
    const topMargin = 20;
    const fontSize = 30;
    infoCtx.textBaseline = "top";
    infoCtx.font = `${fontSize}px dinotopia`;

    infoCtx.fillStyle = !oofTurn ? "red" : "black";
    infoCtx.strokeStyle = !oofTurn ? "red" : "black";
    infoCtx.fillText("Tugg", leftMargin, topMargin);
    for (let i = 0; i < maxHp; i++) {
      (i < tuggHp ? drawLife : drawDeath)(leftMargin + lifeSize * i, topMargin * 2 + fontSize);
    }

    infoCtx.fillStyle = oofTurn ? "red" : "black";
    infoCtx.strokeStyle = oofTurn ? "red" : "black";
    infoCtx.fillText("Oof", leftMargin, (10 * squareSize) - topMargin - fontSize);
    for (let i = 0; i < maxHp; i++) {
      (i < oofHp ? drawLife : drawDeath)(leftMargin + lifeSize * i, (10 * squareSize) - (topMargin + fontSize) * 2);
    }
  }

  function drawLife(x, y) {
    infoCtx.beginPath();
    infoCtx.arc(x + 25, y + 15, 30, 0, Math.PI * 2, true); // Outer circle
    infoCtx.moveTo(x + 44, y + 20);
    infoCtx.arc(x + 25, y + 20, 20, 0, Math.PI, false);  // Mouth (clockwise)
    infoCtx.moveTo(x + 15, y + 5);
    infoCtx.arc(x + 10, y + 5, 5, 0, Math.PI * 2, true);  // Left eye
    infoCtx.moveTo(x + 45, y + 5);
    infoCtx.arc(x + 40, y + 5, 5, 0, Math.PI * 2, true);  // Right eye
    infoCtx.stroke();
  }

  function drawDeath(x, y) {
    infoCtx.beginPath();
    infoCtx.arc(x + 25, y + 15, 30, 0, Math.PI * 2, true); // Outer circle
    infoCtx.moveTo(x + 40, y + 30);
    infoCtx.arc(x + 25, y + 30, 15, 0, Math.PI, true);  // Mouth (clockwise)
    infoCtx.moveTo(x + 10, y);
    infoCtx.lineTo(x + 20, y + 10);
    infoCtx.moveTo(x + 10, y + 10);
    infoCtx.lineTo(x + 20, y);
    infoCtx.moveTo(x + 30, y + 10);
    infoCtx.lineTo(x + 40, y + 20);
    infoCtx.moveTo(x + 40, y + 10);
    infoCtx.lineTo(x + 30, y + 20);
    infoCtx.stroke();
  }

  function draw(){
    drawBoard()
    drawInfo()
  }

  function getPosition(x, y) {
    let boundx = (c) => { return Math.min((squareSize * 8) - 1, Math.max(0, c)); };
    let boundy = (c) => { return Math.min((squareSize * 9) - 1, Math.max(-squareSize, c)); };
    return([Math.floor(boundx(x) / squareSize), Math.floor(boundy(y - squareSize) / squareSize)]);
  }

  function isOpposing(pa, pb) {
    return (
      (isOofPiece(pa)) && (!isOofPiece(pb))
    ) || (
      (isOofPiece(pb)) && (!isOofPiece(pa))
    );
  }

  function getAllowedMoves(position) {
    highlightedSquares = empty();
    highlightedEndzone = empty();
    if(getPiece(position) == 2 || getPiece(position) == 4) {
      return getAllowedGuyMoves(position)
    } else {
      return getAllowedRockMoves(position)
    }
  }

  function getAllowedRockMoves(position) {
    throwRockAllowed = false;
    let allowedMoves = empty();
    let i = position[0];
    while (++i < 8 && !getPiece([i, position[1]])) {
      allowedMoves[i][position[1]] = true;
    }
    if (i < 8) {
      allowedMoves[i][position[1]] = isOpposing(position, [i, position[1]]);
    }

    i = position[0];
    while (--i >= 0 && !getPiece([i, position[1]])) {
      allowedMoves[i][position[1]] = true;
    }
    if (i >= 0) {
      allowedMoves[i][position[1]] = isOpposing(position, [i, position[1]]);
    }

    i = position[1];
    while (++i < 8 && !getPiece([position[0], i])) {
      allowedMoves[position[0]][i] = true;
    }
    if (i < 8) {
      allowedMoves[position[0]][i] = isOpposing(position, [position[0], i]);
    } else if (!isOofPiece(position)) {
      throwRockAllowed = true;
      highlightedEndzone[position[0]][oofTurn ? 0 : 1] = true;
    }

    i = position[1];
    while (--i >= 0 && !getPiece([position[0], i])) {
      allowedMoves[position[0]][i] = true;
    }
    if (i >= 0) {
      allowedMoves[position[0]][i] = isOpposing(position, [position[0], i]);
    } else if (isOofPiece(position)) {
      throwRockAllowed = true;
      highlightedEndzone[position[0]][oofTurn ? 0 : 1] = true;
    }
    return allowedMoves;
  }

  function getAllowedGuyMoves(position) {
    let allowedMoves = empty();
    let i = position[0] + 1;

    if (i < 8) {
      allowedMoves[i][position[1]] = !getPiece([i, position[1]]) || isOpposing(position, [i, position[1]]);
    }

    i = position[0] - 1;

    if (i >= 0) {
      allowedMoves[i][position[1]] = !getPiece([i, position[1]]) || isOpposing(position, [i, position[1]]);
    }

    i = position[1] + 1;

    if (i < 8) {
      allowedMoves[position[0]][i] = !getPiece([position[0], 1]) || isOpposing(position, [position[0], i]);
    }

    i = position[1] - 1;

    if (i >= 0) {
      allowedMoves[position[0]][i] = !getPiece([position[0], 1]) || isOpposing(position, [position[0], i]);
    }

    return allowedMoves;
  }

  function isOofPiece (position) {
    if (getPiece(position) == 1 || getPiece(position) == 2) {
      return true;
    } else {
      return false;
    }
  }

  function getPiece(position) {
    if (position[1] == -1 || position[1] == 8) {
      return -1
    } else {
      return board[position[1]][position[0]];
    }
  }

  function setPiece(position, piece) {
    board[position[1]][position[0]] = piece;
  }

  function changeTurn() {
    oofTurn = !oofTurn
    // if (!oofTurn) {
    //   document.getElementById("tuggTurn").classList.remove("hidden")
    //   document.getElementById("oofTurn").classList.add("hidden")
    // } else {
    //   document.getElementById("tuggTurn").classList.add("hidden")
    //   document.getElementById("oofTurn").classList.remove("hidden")
    // }
  }

  function movePiece(position) {
    let movingPiece = getPiece(activePosition);
    let targetPiece = getPiece(position);
    if (targetPiece == 2 || targetPiece == 4) {
      endGame();
    } else {
      setPiece(position, movingPiece);
      setPiece(activePosition, 0); 
    }
    leaveMoveMode();
    changeTurn();
  }

  function throwRock () {
    console.log('outch');
    setPiece(activePosition, 0);
    if (oofTurn) {
      tuggHp -= 1;
    } else {
      oofHp -= 1;
    }
    if (tuggHp <= 0 || oofHp <= 0) {
      endGame();
    }
    leaveMoveMode();
    changeTurn();
  }

  function endGame() {
    document.write(`you win (${oofTurn ? 'Oof' : 'Tugg'} win)`);
  }

  function enterMoveMode(position) {
    moveMode = true;
    allowedMoves = getAllowedMoves(position);
    activePosition = position;
  }

  function leaveMoveMode() {
    highlightedSquares = empty();
    highlightedEndzone = empty();
    allowedMoves = empty();
    moveMode = false;
  }

  boardCanvas.addEventListener("mousemove", (e) => {
    let position = getPosition(e.offsetX, e.offsetY);
    if (!moveMode) {
      highlightedSquares = empty();
      highlightedSquares[position[0]][position[1]] = true;
      drawBoard();
    }
  });

  boardCanvas.addEventListener("click", (e) => {
    let position = getPosition(e.offsetX, e.offsetY);
    let piece = getPiece(position);
    if (!moveMode && piece && (isOofPiece(position) && oofTurn || !isOofPiece(position) && !oofTurn)) {
      enterMoveMode(position);
    } else if (moveMode) {
      if (piece >= 0 && allowedMoves[position[0]][position[1]]) {
        movePiece(position);
      } else if(throwRockAllowed && (position[1] == -1 && oofTurn || position[1] == 8 && !oofTurn)){
        throwRock();
      } else {
        leaveMoveMode();
      }
    }
    draw();
  });

  draw();
})
</script>
</body>
</html>